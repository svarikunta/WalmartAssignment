package com.wallmart.service;

import java.util.ArrayList;
import java.util.List;

import com.wallmat.model.Custmore;
import com.wallmat.model.FindAvailableResponse;
import com.wallmat.model.ReserveAndCommitRequest;
import com.wallmat.model.ReserveAndCommitResponse;
import com.wallmat.model.FindAndHoldRequest;
import com.wallmat.model.FindAndHoldResponse;
import com.wallmat.model.Seat;
import com.wallmat.model.Stage;
import com.walmart.Constats.Constants;

public class TicketingServiceImplHelper {

	HoldTimer held = new HoldTimer();

	Stage stage =  Stage.getInstance();

	public FindAndHoldResponse findAvilableSeatAndHeld(FindAndHoldRequest request) {

		FindAndHoldResponse response = new FindAndHoldResponse();
		
		response.setCustmore(request.getCustmore());

		Character custPreferdRow = request.getCustPreferedRow();

		List<Seat> availableSeats = new ArrayList<Seat>();

		int reqNumbOfSeats = request.getReqNumbOfSeats();

		if (reqNumbOfSeats > Stage.seatsAvilable.get()) {

			response.setStatus(FindAndHoldResponse.Status.SeatsNotAvilable);
			response.setMesaage("Currently, " + Stage.seatsAvilable.get() + " seats are available so couldn’t book "
					+ reqNumbOfSeats + " tickets ");
		}

		if (null != custPreferdRow) {

			availableSeats.addAll(findAvailableSeatsInARow(custPreferdRow, reqNumbOfSeats));

			if (availableSeats.size() == reqNumbOfSeats) {
				if (holdAvilableSeats(availableSeats, request.getCustmore())) {
					response.setStatus(FindAndHoldResponse.Status.Sucess);
					response.setMesaage("Requested " + reqNumbOfSeats + " tickets are in Hold for "
							+ Constants.HOLD_TIME / 1000 + "seconds please resorve before hold time");
					response.setSeatsHeld(availableSeats);
					response.setTotalAvailableSeats(Stage.seatsAvilable.get());
					
					return response;
				} else {
					response.setStatus(FindAndHoldResponse.Status.Eror);
					response.setMesaage("Error during Hold process please retry again");
					response.setTotalAvailableSeats(Stage.seatsAvilable.get());
					return response;
				}

			} else {

				availableSeats.addAll(
						findAvailableSeatsInNearestRows(custPreferdRow, reqNumbOfSeats - availableSeats.size()));

				if (availableSeats.size() == reqNumbOfSeats) {
					response.setStatus(FindAndHoldResponse.Status.NeedConfirm);
					response.setMesaage("Requested " + reqNumbOfSeats
							+ " ticketes are not avilabel in same row please review seat number and confirm Y/N");
					response.setSeatsHeld(availableSeats);
					response.setTotalAvailableSeats(Stage.seatsAvilable.get());
					return response;
				}

				if (availableSeats.size() < reqNumbOfSeats) {

					response.setBestAvilableSeats(availableSeats);
					response.setStatus(FindAndHoldResponse.Status.SeatsNotAvilable);
					response.setMesaage("Currently, " + Stage.seatsAvilable.get()
							+ " seats are available so couldn’t book " + reqNumbOfSeats + " tickets ");
					response.setTotalAvailableSeats(Stage.seatsAvilable.get());
					return response;
				}

			}

		} else {

			availableSeats.addAll(findAvailableSeatsInTheStage(reqNumbOfSeats));

			if (availableSeats.size() == reqNumbOfSeats) {

				if (holdAvilableSeats(availableSeats, request.getCustmore())) {
					response.setStatus(FindAndHoldResponse.Status.Sucess);
					response.setMesaage("Requested " + reqNumbOfSeats + " tickets are in Hold for "
							+ Constants.HOLD_TIME / 1000 + "seconds please resorve before hold time");
					response.setSeatsHeld(availableSeats);
					response.setTotalAvailableSeats(Stage.seatsAvilable.get());
					return response;
				} else {
					response.setStatus(FindAndHoldResponse.Status.Eror);
					response.setMesaage("Error during Hold process please retry again");
					response.setTotalAvailableSeats(Stage.seatsAvilable.get());
					return response;
				}
			}

			if (availableSeats.size() < reqNumbOfSeats) {

				response.setBestAvilableSeats(availableSeats);
				response.setStatus(FindAndHoldResponse.Status.SeatsNotAvilable);
				response.setMesaage("Currently, " + Stage.seatsAvilable.get() + " seats are available so couldn’t book "
						+ reqNumbOfSeats + " tickets ");
				response.setTotalAvailableSeats(Stage.seatsAvilable.get());
				return response;
			}
		}

		return response;

	}
	
	
	public FindAndHoldResponse holdSeats(FindAndHoldRequest request){
		
		List<Seat> avilableSeats=request.getCustPreferdSeats();
		Custmore custmore=request.getCustmore();
		FindAndHoldResponse response= new FindAndHoldResponse();
		
		if(holdAvilableSeats(avilableSeats,custmore)){
			response.setStatus(FindAndHoldResponse.Status.Sucess);
			response.setMesaage("Requested " + avilableSeats.size() + " tickets are in Hold for "
					+ Constants.HOLD_TIME / 1000 + "seconds please resorve before hold time");
			response.setSeatsHeld(avilableSeats);
			response.setTotalAvailableSeats(Stage.seatsAvilable.get());
			return response;
			
		}else{
			response.setStatus(FindAndHoldResponse.Status.Eror);
			response.setMesaage("Requested Seats are not avialable");
			response.setTotalAvailableSeats(Stage.seatsAvilable.get());
			return response;
		}
		
	
		
	}

	public boolean holdAvilableSeats(List<Seat> avilableSeats, Custmore custmore) {

		List<Seat> heldSeats = new ArrayList<Seat>();

		for (Seat seat : avilableSeats) {

			String key = seat.getRowNo().toString() + seat.getColNo();

			Seat st = stage.getSeatMap().get(key);

			if (st.isAvilable()) {
				st.setState(Seat.State.H);
				st.setCustmore(custmore);
				heldSeats.add(st);
				Stage.seatsAvilable.getAndDecrement();
				Stage.seatsHeld.getAndIncrement();
				stage.getSeatMap().put(key,st);

			}
			
		}

		if (avilableSeats.size() != heldSeats.size()) {

			if(heldSeats.size()>0)
			releaseHeldSeats(heldSeats);
			
			return false;
		}

		held.updateHedStatus(heldSeats);
		return true;

	}

	private void releaseHeldSeats(List<Seat> heldSeats) {

		for (Seat st : heldSeats) {

			String key = st.getRowNo().toString() + st.getColNo();

			st = stage.getSeatMap().get(key);

			if (st.isHeld()) {

				st.setState(Seat.State.A);
				st.setCustmore(null);
				Stage.seatsAvilable.getAndIncrement();
				Stage.seatsHeld.getAndDecrement();
				st = stage.getSeatMap().put(key, st);

			}

			
		}

	}
	
	private void releaseReservedSeats(List<Seat> reservedSeats) {

		for (Seat st : reservedSeats) {

			String key = st.getRowNo().toString() + st.getColNo();

			st = stage.getSeatMap().get(key);

			if (st.isReserved()) {

				st.setState(Seat.State.A);
				st.setCustmore(null);
				Stage.seatsAvilable.getAndIncrement();
				Stage.seatsReserved.getAndDecrement();
				st = stage.getSeatMap().put(key, st);

			}

			
		}

	}

	public ReserveAndCommitResponse reserveAndCommit(ReserveAndCommitRequest request) {

		List<Seat> heldSeats = request.getSeatsHeld();
		List<Seat> reservedList = null;
		Custmore cust = request.getCustmore();
		ReserveAndCommitResponse response = new ReserveAndCommitResponse();
		response.setCustmore(request.getCustmore());

		reservedList=resorveAndCommit(heldSeats,cust);
	
		
		if (heldSeats.size() == reservedList.size()) {
			response.setStatus(ReserveAndCommitResponse.Status.Sucess);
			response.setMesaage(" Requested " + heldSeats.size()+ " seats are resorved");
		} else {
			response.setStatus(ReserveAndCommitResponse.Status.Eror);
			response.setMesaage("Error during resorvation process please retry again");

		}

		response.setSeatsResorved(reservedList);
		return response;

	}
	
	public List<Seat> resorveAndCommit(List<Seat> heldSeats, Custmore custmore) {

		
		List<Seat> resorvedList = new ArrayList<Seat>();
	

		for (Seat st : heldSeats) {

			String key = st.getRowNo().toString() + st.getColNo();

			st = stage.getSeatMap().get(key);

			if (st.isHeld()) {
				if (null != st.getCustmore() && st.getCustmore().getCustmoreId() == custmore.getCustmoreId()) {

					st.setState(Seat.State.R);
					Stage.seatsReserved.getAndIncrement();
					Stage.seatsHeld.getAndDecrement();
					resorvedList.add(st);
					st = stage.getSeatMap().put(key, st);
				}

			}

			
		}
		
		if (heldSeats.size() != resorvedList.size()) {

			if(resorvedList.size()>0){
			releaseReservedSeats(resorvedList);
			resorvedList.clear();
			}
			
		}
	
		return resorvedList;

	}

	

	public List<Seat> findAvailableSeatsInARow(Character preferedRow, int reqNumSeats) {
		int count = 0;

		List<Seat> availableSeats = new ArrayList<Seat>();

		for (int i = 0; i < reqNumSeats; i++) {

			for (int col = 1; col <= stage.getNoColums(); col++) {

				String key = preferedRow.toString() + col;
				Seat st = stage.getSeatMap().get(key);

				if (st.isAvilable() ) {

					availableSeats.add(st);
					count++;
					if (count == reqNumSeats)
						return availableSeats;
				}

			}

		}

		return availableSeats;
	}

	public List<Seat> findAvailableSeatsInNearestRows(Character preferedRow, int reqNumSeats) {
		int count = 0;

		List<Seat> availableSeats = new ArrayList<Seat>();

		// Check for Available Seats in the back rows.
		for (Character row = ++preferedRow; row <= stage.getNoOfRow(); row++) {

			for (int col = 1; col <= stage.getNoColums(); col++) {

				String key = row.toString() + col;
				Seat st = stage.getSeatMap().get(key);

				if (st.isAvilable()) {

					availableSeats.add(st);
					count++;
					if (count == reqNumSeats)
						return availableSeats;
				}

			}

		}

		// Check for Available Seats in the front rows.
		for (Character row = --preferedRow; row >= 'A'; row--) {
			for (int col = 1; col <= stage.getNoColums(); col++) {

				String key = row.toString() + col;
				Seat st = stage.getSeatMap().get(key);

				if (st.isAvilable()) {

					availableSeats.add(st);
					count++;
					if (count == reqNumSeats)
						return availableSeats;
				}

			}
		}

		return availableSeats;
	}

	

	public List<Seat> findAvailableSeatsInTheStage(int reqNumSeats) {

		int count = 0;

		List<Seat> availableSeats = new ArrayList<Seat>();

		for (Character row = 'A'; row <= stage.getNoOfRow(); row++) {

			for (int col = 1; col <= stage.getNoColums(); col++) {

				String key = row.toString() + col;
				Seat st = stage.getSeatMap().get(key);

				if (st.isAvilable() ) {

					availableSeats.add(st);
					count++;
					if (count == reqNumSeats)
					return availableSeats;

				}

			}

		}

		return availableSeats;
	}



	public void displayStage() {

		for (int col = 1; col <= stage.getNoColums(); col++) {

			System.out.print("\t" + col);

		}

		System.out.println();

		for (Character row = 'A'; row <= stage.getNoOfRow(); row++) {

			System.out.print(row);

			for (int col = 1; col <= stage.getNoColums(); col++) {

				String key = row.toString() + col;
				Seat st = stage.getSeatMap().get(key);
				System.out.print("\t" + st.getState());

			}

			System.out.println();

		}
		System.out.println("A - Available : " + Stage.seatsAvilable);
		System.out.println("H - Hold : " + Stage.seatsHeld);
		System.out.println("A - Reserved : " + Stage.seatsReserved);
	}


	public FindAvailableResponse findNoOfSeatsAvilable() {
		
		FindAvailableResponse response = new FindAvailableResponse();
		
		response.setTotalAvailableSeats(Stage.seatsAvilable.get());
		response.setTotalHeldSeats(Stage.seatsHeld.get());
		response.setTotalReservedSeats(Stage.seatsReserved.get());
		
		return response;
	}




}
