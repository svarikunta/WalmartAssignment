package com.wallmart.service;

import java.util.ArrayList;
import java.util.List;

import com.wallmat.model.Custmore;
import com.wallmat.model.ResorvationRequest;
import com.wallmat.model.ResorvationResponse;
import com.wallmat.model.Seat;
import com.wallmat.model.Stage;
import com.walmart.Constats.Constants;

public class TicketingServiceImplHelper {

	HoldTimer held = new HoldTimer();

	Stage stage = new Stage('G', 10);

	public ResorvationResponse findAvilableSeatAndHeld(ResorvationRequest request) {

		ResorvationResponse response = new ResorvationResponse();
		response.setCustmore(request.getCustmore());

		Character custPreferdRow = request.getCustPreferedRow();

		List<Seat> availableSeats = new ArrayList<Seat>();

		int reqNumbOfSeats = request.getReqNumbOfSeats();

		if (reqNumbOfSeats > Stage.seatsAvilable.get()) {

			response.setStatus(ResorvationResponse.Status.SeatsNotAvilable);
			response.setMesaage("Currently, " + Stage.seatsAvilable.get() + " seats are available so couldn’t book "
					+ reqNumbOfSeats + " tickets ");
		}

		if (null != custPreferdRow) {

			availableSeats.addAll(findAvailableSeatsInARow(custPreferdRow, reqNumbOfSeats));

			if (availableSeats.size() == reqNumbOfSeats) {
				if (holdAvilableSeats(availableSeats, request.getCustmore())) {
					response.setStatus(ResorvationResponse.Status.Sucess);
					response.setMesaage("Requested " + reqNumbOfSeats + " tickets are in Hold for "
							+ Constants.HOLD_TIME / 1000 + "seconds please resorve before hold time");
					response.setSeatsHeld(availableSeats);
					return response;
				} else {
					response.setStatus(ResorvationResponse.Status.Eror);
					response.setMesaage("Error during Hold process please retry again");
					return response;
				}

			} else {

				availableSeats.addAll(
						findAvailableSeatsInNearestRows(custPreferdRow, reqNumbOfSeats - availableSeats.size()));

				if (availableSeats.size() == reqNumbOfSeats) {
					response.setStatus(ResorvationResponse.Status.NeedConfirm);
					response.setMesaage("Requested " + reqNumbOfSeats
							+ " ticketes are not avilabel in same row please review seat number and confirm Y/N");
					response.setSeatsHeld(availableSeats);
					return response;
				}

				if (availableSeats.size() < reqNumbOfSeats) {

					response.setBestAvilableSeats(availableSeats);
					response.setStatus(ResorvationResponse.Status.SeatsNotAvilable);
					response.setMesaage("Currently, " + Stage.seatsAvilable.get()
							+ " seats are available so couldn’t book " + reqNumbOfSeats + " tickets ");
					return response;
				}

			}

		} else {

			availableSeats.addAll(findAvailableSeatsInTheStage(reqNumbOfSeats));

			if (availableSeats.size() == reqNumbOfSeats) {

				if (holdAvilableSeats(availableSeats, request.getCustmore())) {
					response.setStatus(ResorvationResponse.Status.Sucess);
					response.setMesaage("Requested " + reqNumbOfSeats + " tickets are in Hold for "
							+ Constants.HOLD_TIME / 1000 + "seconds please resorve before hold time");
					response.setSeatsHeld(availableSeats);
					return response;
				} else {
					response.setStatus(ResorvationResponse.Status.Eror);
					response.setMesaage("Error during Hold process please retry again");
					return response;
				}
			}

			if (availableSeats.size() < reqNumbOfSeats) {

				response.setBestAvilableSeats(availableSeats);
				response.setStatus(ResorvationResponse.Status.SeatsNotAvilable);
				response.setMesaage("Currently, " + Stage.seatsAvilable.get() + " seats are available so couldn’t book "
						+ reqNumbOfSeats + " tickets ");
				return response;
			}
		}

		return response;

	}

	public boolean holdAvilableSeats(List<Seat> avilableSeats, Custmore custmore) {

		List<Seat> heldSeats = new ArrayList<Seat>();

		for (Seat seat : avilableSeats) {

			String key = seat.getRowNo().toString() + seat.getColNo();

			Seat st = stage.getSeatMap().get(key);

			if (st.isAvilable()) {
				st.setStatus(Seat.Status.H);
				st.setCustmore(custmore);
				heldSeats.add(st);
				Stage.seatsAvilable.getAndDecrement();
				Stage.seatsHeld.getAndIncrement();

			}

		}

		if (avilableSeats.size() != heldSeats.size()) {

			relseHeldSeats(heldSeats, custmore);
			return false;
		}

		held.updateHedStatus(heldSeats);
		return true;

	}

	private void relseHeldSeats(List<Seat> heldSeats, Custmore custmore) {

		for (Seat st : heldSeats) {

			String key = st.getRowNo().toString() + st.getColNo();

			st = stage.getSeatMap().get(key);

			if (st.isHeld()) {

				st.setStatus(Seat.Status.A);
				st.setCustmore(null);
				Stage.seatsAvilable.getAndIncrement();
				Stage.seatsHeld.getAndDecrement();

			}

			st = stage.getSeatMap().put(key, st);
		}

	}



	public ResorvationResponse resorveAndCommit(ResorvationRequest request) {

		List<Seat> heldSeats = request.getSeatsHeld();
		List<Seat> resorvedList = new ArrayList<Seat>();
		Custmore cust = request.getCustmore();
		ResorvationResponse response = new ResorvationResponse();
		response.setCustmore(request.getCustmore());

		for (Seat st : heldSeats) {

			String key = st.getRowNo().toString() + st.getColNo();

			st = stage.getSeatMap().get(key);

			if (st.isHeld()) {
				if (null != st.getCustmore() && st.getCustmore().getCustmoreId() == cust.getCustmoreId()) {

					st.setStatus(Seat.Status.R);
					Stage.seatsReserved.getAndIncrement();
					Stage.seatsHeld.getAndDecrement();
					resorvedList.add(st);
				}

			}

			st = stage.getSeatMap().put(key, st);
		}
		if (heldSeats.size() == resorvedList.size()) {
			response.setStatus(ResorvationResponse.Status.Sucess);
			response.setMesaage(" Requested " + request.getReqNumbOfSeats()+ "are resorved");
		} else {
			response.setStatus(ResorvationResponse.Status.Eror);
			response.setMesaage("Error during resorvation process please retry again");

		}

		response.setSeatsResorved(resorvedList);
		return response;

	}

	

	public List<Seat> findAvailableSeatsInARow(Character preferedRow, int reqNumSeats) {
		int count = 0;

		List<Seat> availableSeats = new ArrayList<Seat>();

		for (int i = 0; i < reqNumSeats; i++) {

			for (int col = 1; col <= stage.getNoColums(); col++) {

				String key = preferedRow.toString() + col;
				Seat st = stage.getSeatMap().get(key);

				if (st.isAvilable() && !contains(availableSeats, st)) {

					availableSeats.add(st);
					count++;
					if (count == reqNumSeats)
						return availableSeats;
				}

			}

		}

		return availableSeats;
	}

	public List<Seat> findAvailableSeatsInNearestRows(Character preferedRow, int reqNumSeats) {
		int count = 0;

		List<Seat> availableSeats = new ArrayList<Seat>();

		// Check for Available Seats in the back rows.
		for (Character row = ++preferedRow; row <= stage.getNoOfRow(); row++) {

			for (int col = 1; col <= stage.getNoColums(); col++) {

				String key = row.toString() + col;
				Seat st = stage.getSeatMap().get(key);

				if (st.isAvilable() && !contains(availableSeats, st)) {

					availableSeats.add(st);
					count++;
					if (count == reqNumSeats)
						return availableSeats;
				}

			}

		}

		// Check for Available Seats in the front rows.
		for (Character row = --preferedRow; row >= 'A'; row--) {
			for (int col = 1; col <= stage.getNoColums(); col++) {

				String key = row.toString() + col;
				Seat st = stage.getSeatMap().get(key);

				if (st.isAvilable() && !contains(availableSeats, st)) {

					availableSeats.add(st);
					count++;
					if (count == reqNumSeats)
						return availableSeats;
				}

			}
		}

		return availableSeats;
	}

	public List<Seat> findAvailableSeatsInOtherRows(Character preferedRow, int reqNumSeats) {
		int count = 0;

		List<Seat> availableSeats = new ArrayList<Seat>();

		for (int i = 0; i < reqNumSeats; i++) {

			for (Character row = 'A'; row <= stage.getNoOfRow(); row++) {
				if (row != preferedRow) {
					for (int col = 1; col <= stage.getNoColums(); col++) {

						String key = row.toString() + col;
						Seat st = stage.getSeatMap().get(key);

						if (st.isAvilable() && !contains(availableSeats, st)) {

							availableSeats.add(st);
							count++;
							if (count == reqNumSeats)
								return availableSeats;
						}

					}
				}

			}
		}

		return availableSeats;
	}

	public List<Seat> findAvailableSeatsInTheStage(int reqNumSeats) {

		int count = 0;

		List<Seat> availableSeats = new ArrayList<Seat>();

		for (Character row = 'A'; row <= stage.getNoOfRow(); row++) {

			for (int col = 1; col <= stage.getNoColums(); col++) {

				String key = row.toString() + col;
				Seat st = stage.getSeatMap().get(key);

				if (st.isAvilable() && !contains(availableSeats, st)) {

					availableSeats.add(st);
					count++;
					if (count == reqNumSeats)
						return availableSeats;

				}

			}

		}

		return availableSeats;
	}

	public boolean contains(List<Seat> availableSeats, Seat seat) {

		for (Seat st : availableSeats) {

			if (st.getRowNo().equals(seat.getRowNo()) && st.getColNo() == seat.getColNo()) {
				return true;
			}
		}

		return false;
	}

	public void displayStage() {

		for (int col = 1; col <= stage.getNoColums(); col++) {

			System.out.print("\t" + col);

		}

		System.out.println();

		for (Character row = 'A'; row <= stage.getNoOfRow(); row++) {

			System.out.print(row);

			for (int col = 1; col <= stage.getNoColums(); col++) {

				String key = row.toString() + col;
				Seat st = stage.getSeatMap().get(key);
				System.out.print("\t" + st.getStatus());

			}

			System.out.println();

		}
		System.out.println("A - Available : " + Stage.seatsAvilable);
		System.out.println("H - Hold : " + Stage.seatsHeld);
		System.out.println("A - Reserved : " + Stage.seatsReserved);
	}

}
